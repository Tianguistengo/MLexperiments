

- (regulatization) Lasso is great for feature selection, but when building regression models, 
Ridge regression should be your first choice.

-Logistic regression is for classficiation, not regression. 

- property DataFrame.values

    Return a Numpy representation of the DataFrame.

    Warning

    We recommend using DataFrame.to_numpy() instead.

    Only the values in the DataFrame will be returned, the axes labels will be removed.
    
    
 -the greater the AUC (aread under the curve) the better the model
  If the AUC is greater than 0.5, the model is better than random guessing. Always a good sign! 

-After computing the GridSeachCV, I not just want the best params but also the best score:
# Print the tuned parameters and score
print("Tuned Logistic Regression Parameters: {}".format(logreg_cv.best_params_)) 
print("Best score is {}".format(logreg_cv.best_score_))


-Note that RandomizedSearchCV will never outperform GridSearchCV. 
Instead, it is valuable because it saves on computation time.

- format()  function https://www.geeksforgeeks.org/python-format-function/
print ("Hello, I am {} years old !".format(18))

-Exploratory data analysis should always be the precursor to model building.

-axis=0 means columns
axis=1 means rows


-"
# Convert '?' to NaN
df[df == '?'] = np.nan

# Print the number of NaNs
print(df.isnull().sum())
"

--imputation == transformation
"    # Setup the Imputation transformer: imp
imp = Imputer(missing_values='NaN', strategy='most_frequent', axis=0)
"

-"
You can use the .fit() and .predict() methods on pipelines just as you did with your classifiers and regressors"

-" ROC (receiver operating characteristic) Curve

A curve of true positive rate vs. false positive rate at different classification thresholds. See also AUC.


-To loop through a set of code a specified number of times, we can use the ----range()---- function.
When you use a range loop you are saying that you want to count one by one from one number until you hit another.

-The ELSE keyword in a for loop specifies a block of code to be executed when the loop is finished:

-round () to round a float to an interger

-True es 1 y False es 0

-sorted ()  los ordena de menor a mayor

-help(len) opens up the documentation from inside the IPython Shell for the len() function

-numpy.column_stack() function is used to stack 1-D arrays as columns into a 2-D array.
It takes a sequence of 1-D arrays and stack them as columns to make a single 2-D array.

import numpy as geek 
  
# input array 
in_arr1 = geek.array(( 1, 2, 3 )) 
print ("1st Input array : \n", in_arr1)  
  
in_arr2 = geek.array(( 4, 5, 6 )) 
print ("2nd Input array : \n", in_arr2)  
  
# Stacking the two arrays  
------>out_arr = geek.column_stack((in_arr1, in_arr2)) 
print ("Output stacked array:\n ", out_arr) 
Output:

1st Input array : 
 [1 2 3]
2nd Input array : 
 [4 5 6]
------->Output stacked array:
  [[1 4]
 [2 5]
 [3 6]]


- np.corrcoef      Return correlation coefficients.
















